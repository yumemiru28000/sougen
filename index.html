<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ËçâÂéü„ÅÆ‰ª≤Èñì„Åü„Å°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #4a7c3c;
        }

        #grassland-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #4a7c3c;
        }

        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #background img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
        }

        #character-counter {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            color: #2d5016;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .character {
            position: absolute;
            cursor: pointer;
            transition: transform 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            will-change: transform;
        }

        .character img {
            width: 100%;
            height: 100%;
            pointer-events: none;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .character:hover {
            transform: scale(1.05);
        }

        .emoji-particle {
            position: absolute;
            font-size: 24px;
            pointer-events: none;
            z-index: 1000;
            animation: floatEmoji 2s ease-out forwards;
        }

        @keyframes floatEmoji {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-120px) translateX(var(--drift-x)) scale(1.2);
            }
        }

        .heart-particle {
            position: absolute;
            font-size: 16px;
            pointer-events: none;
            z-index: 999;
            opacity: 0.7;
            animation: gentleFloat 3s ease-out infinite;
        }

        @keyframes gentleFloat {
            0% {
                opacity: 0.7;
                transform: translateY(0) translateX(0);
            }
            50% {
                opacity: 0.4;
                transform: translateY(-30px) translateX(10px);
            }
            100% {
                opacity: 0.2;
                transform: translateY(-60px) translateX(-5px);
            }
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #overlay.active {
            display: flex;
        }

        #overlay-content {
            position: relative;
            max-width: 90%;
            max-height: 90%;
            animation: scaleIn 0.3s ease;
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        #overlay-content img {
            max-width: 100%;
            max-height: 90vh;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #close-overlay {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 40px;
            height: 40px;
            background: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, background 0.2s;
            font-weight: bold;
            color: #333;
        }

        #close-overlay:hover {
            transform: scale(1.1) rotate(90deg);
            background: #ff6b6b;
            color: white;
        }

        .gif-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
    </style>
</head>
<body>
    <div id="grassland-container">
        <div id="background">
            <img src="sibahu1.png" alt="ËçâÂéü" id="grass-bg">
        </div>
        <div id="character-counter">0/0</div>
    </div>

    <div id="overlay">
        <div id="overlay-content">
            <button id="close-overlay">√ó</button>
            <img id="overlay-image" src="" alt="„Ç≠„É£„É©„ÇØ„Çø„ÉºË©≥Á¥∞">
        </div>
    </div>

    <script>
        // ========== „Ç≠„É£„É©„ÇØ„Çø„ÉºË®≠ÂÆö ==========
        const characters = [
            {
                name: '„ÅÜ„Å®„ÅÜ„Å®',
                image: 'cara1.png',
                detailImage: 'cara1.png',
                emoji: ['üíï', '‚ú®', 'üå∏'],
                size: 5,
                moveType: 3, // „Å¥„Çá„Çì„Å¥„Çá„ÇìË∑≥„Å≠„Çã
                moveTime: 3, // ÁßªÂãïÊôÇÈñìÔºàÁßíÔºâ
                restTime: 2, // ‰ºëÊÜ©ÊôÇÈñìÔºàÁßíÔºâ
                moveArea: 1, // ‰∏ãÈÉ®1/3
                affection: 2, // „Ç´„Éº„ÇΩ„É´„Å´Ëøë„Å•„Åè
                gifImage: '', // ‰æã: 'cara1.gif'
                gifDuration: 2000, // gifË°®Á§∫ÊôÇÈñìÔºà„Éü„É™ÁßíÔºâ
            },
            {
                name: '„Åô„Åø„Çå',
                image: 'cara2.png',
                detailImage: 'cara2.png',
                emoji: ['üò∫', 'üêæ', 'üíõ'],
                size: 4,
                moveType: 2, // „Åô„Éº„Å£„Å®Êªë„Çã
                moveTime: 4,
                restTime: 3,
                moveArea: 2, // ‰∏≠Â§Æ1/3
                affection: 3, // „ÇØ„É™„ÉÉ„ÇØ„ÅßÊáê„Åè
                gifImage: '',
                gifDuration: 2000,
            },
            {
                name: '„Åì„Å®„Çä„Å°„ÇÉ„Çì',
                image: 'cara3.png',
                detailImage: 'cara3.png',
                emoji: ['üéµ', 'üåà', 'üíô'],
                size: 15,
                moveType: 2,
                moveTime: 2,
                restTime: 1,
                moveArea: 3, // ‰∏äÈÉ®2/3
                affection: 4, // ÊÑõÁùÄÂ∫¶Ê©üËÉΩ„Å™„Åó
                gifImage: '',
                gifDuration: 2000,
            },
            {
                name: '„Åè„Åæ„Åè„Çì',
                image: 'cara4.png',
                detailImage: 'cara4.png',
                emoji: ['üçØ', 'üíö', 'üåü'],
                size: 35,
                moveType: 2,
                moveTime: 5,
                restTime: 4,
                moveArea: 1,
                affection: 1, // ÈÄÉ„Åí„Çã
                gifImage: '',
                gifDuration: 2000,
            },
            {
                name: '„Åç„Å§„Å≠„Åï„Çì',
                image: 'cara5.png',
                detailImage: 'cara5.png',
                emoji: ['ü¶ä', 'üî•', 'üß°'],
                size: 30,
                moveType: 3,
                moveTime: 3,
                restTime: 2,
                moveArea: 2,
                affection: 2,
                gifImage: '',
                gifDuration: 2000,
            },
        ];

        // ========== „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ ==========
        let activeCharacters = [];
        let mouseX = 0;
        let mouseY = 0;
        const ROTATION_INTERVAL = 5 * 60 * 1000; // 5ÂàÜ
        const MAX_ACTIVE = 3;

        // ========== ÂàùÊúüÂåñ ==========
        function init() {
            updateCounter();
            selectRandomCharacters();
            setInterval(rotateCharacters, ROTATION_INTERVAL);
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            document.getElementById('close-overlay').addEventListener('click', closeOverlay);
            document.getElementById('overlay').addEventListener('click', (e) => {
                if (e.target === document.getElementById('overlay')) {
                    closeOverlay();
                }
            });
        }

        // ========== „Ç´„Ç¶„É≥„Çø„ÉºÊõ¥Êñ∞ ==========
        function updateCounter() {
            const counter = document.getElementById('character-counter');
            counter.textContent = `${activeCharacters.length}/${characters.length}`;
        }

        // ========== „É©„É≥„ÉÄ„É†„Ç≠„É£„É©„ÇØ„Çø„ÉºÈÅ∏Êäû ==========
        function selectRandomCharacters() {
            // Êó¢Â≠ò„ÅÆ„Ç≠„É£„É©„ÇØ„Çø„Éº„ÇíÂâäÈô§
            activeCharacters.forEach(char => {
                if (char.element) {
                    char.element.remove();
                }
                if (char.moveInterval) clearInterval(char.moveInterval);
                if (char.gifInterval) clearInterval(char.gifInterval);
                if (char.affectionInterval) clearInterval(char.affectionInterval);
            });
            activeCharacters = [];

            // „É©„É≥„ÉÄ„É†„Å´3ÂåπÈÅ∏Êäû
            const shuffled = [...characters].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, Math.min(MAX_ACTIVE, characters.length));

            selected.forEach(char => {
                createCharacter(char);
            });

            updateCounter();
        }

        // ========== „Ç≠„É£„É©„ÇØ„Çø„ÉºÂõûËª¢ ==========
        function rotateCharacters() {
            selectRandomCharacters();
        }

        // ========== „Ç≠„É£„É©„ÇØ„Çø„Éº‰ΩúÊàê ==========
        function createCharacter(charData) {
            const container = document.getElementById('grassland-container');
            const char = { ...charData };
            
            // „Çµ„Ç§„Ç∫Ë®àÁÆóÔºà1-50 ‚Üí ÂÆüÈöõ„ÅÆ„Éî„ÇØ„Çª„É´„Çµ„Ç§„Ç∫Ôºâ
            const minSize = 60;
            const maxSize = window.innerHeight / 2;
            char.actualSize = minSize + (char.size / 50) * (maxSize - minSize);

            // „Ç≠„É£„É©„ÇØ„Çø„ÉºË¶ÅÁ¥†‰ΩúÊàê
            const element = document.createElement('div');
            element.className = 'character';
            element.style.width = `${char.actualSize}px`;
            element.style.height = `${char.actualSize}px`;
            
            const img = document.createElement('img');
            img.src = char.image;
            img.alt = char.name;
            element.appendChild(img);

            // ÂàùÊúü‰ΩçÁΩÆË®≠ÂÆö
            const bounds = getMovementBounds(char.moveArea);
            char.x = Math.random() * (bounds.maxX - bounds.minX) + bounds.minX;
            char.y = Math.random() * (bounds.maxY - bounds.minY) + bounds.minY;
            char.direction = 1; // 1: Âè≥Âêë„Åç, -1: Â∑¶Âêë„Åç
            char.isMoving = false;
            char.isFriendly = (char.affection === 3) ? false : (char.affection === 2);
            char.friendlyUntil = 0;

            element.style.left = `${char.x}px`;
            element.style.top = `${char.y}px`;

            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            element.addEventListener('click', (e) => handleClick(e, char));
            element.addEventListener('dblclick', (e) => handleDoubleClick(e, char));

            container.appendChild(element);
            char.element = element;
            char.img = img;

            activeCharacters.push(char);

            // Âãï„ÅçÈñãÂßã
            if (char.moveType > 1) {
                startMovement(char);
            }

            // GIFÂàá„ÇäÊõø„Åà
            if (char.gifImage) {
                startGifCycle(char);
            }

            // ÊÑõÁùÄÂ∫¶„Ç∑„Çπ„ÉÜ„É†
            if (char.affection === 2 || char.affection === 3) {
                startAffectionBehavior(char);
            } else if (char.affection === 1) {
                startAvoidanceBehavior(char);
            }
        }

        // ========== ÁßªÂãïÁØÑÂõ≤ÂèñÂæó ==========
        function getMovementBounds(moveArea) {
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            let minY, maxY;
            if (moveArea === 1) { // ‰∏ãÈÉ®1/3
                minY = h * 2/3;
                maxY = h;
            } else if (moveArea === 2) { // ‰∏≠Â§Æ1/3
                minY = h * 1/3;
                maxY = h * 2/3;
            } else { // ‰∏äÈÉ®2/3
                minY = 0;
                maxY = h * 2/3;
            }

            return {
                minX: 0,
                maxX: w,
                minY: minY,
                maxY: maxY
            };
        }

        // ========== ÁßªÂãï„Ç∑„Çπ„ÉÜ„É† ==========
        function startMovement(char) {
            const move = () => {
                if (char.isMoving) {
                    const duration = (char.moveTime + (Math.random() - 0.5)) * 1000;
                    setTimeout(() => {
                        char.isMoving = false;
                        rest();
                    }, Math.max(1000, duration));
                    
                    if (char.moveType === 2) {
                        smoothMove(char);
                    } else if (char.moveType === 3) {
                        hopMove(char);
                    }
                } else {
                    rest();
                }
            };

            const rest = () => {
                const duration = (char.restTime + (Math.random() - 0.5)) * 1000;
                setTimeout(() => {
                    char.isMoving = true;
                    move();
                }, Math.max(500, duration));
            };

            char.isMoving = Math.random() > 0.5;
            move();
        }

        // ========== „Çπ„É†„Éº„Ç∫ÁßªÂãï ==========
        function smoothMove(char) {
            const bounds = getMovementBounds(char.moveArea);
            const targetX = Math.random() * (bounds.maxX - bounds.minX - char.actualSize) + bounds.minX;
            const targetY = Math.random() * (bounds.maxY - bounds.minY - char.actualSize) + bounds.minY;
            
            const duration = (char.moveTime + (Math.random() - 0.5) * 0.5) * 1000;
            const startX = char.x;
            const startY = char.y;
            const startTime = Date.now();

            // Âêë„ÅçË®≠ÂÆö
            if (targetX > char.x && char.direction === -1) {
                char.img.style.transform = 'scaleX(1)';
                char.direction = 1;
            } else if (targetX < char.x && char.direction === 1) {
                char.img.style.transform = 'scaleX(-1)';
                char.direction = -1;
            }

            const animate = () => {
                if (!char.isMoving) return;

                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = easeInOutQuad(progress);

                char.x = startX + (targetX - startX) * easeProgress;
                char.y = startY + (targetY - startY) * easeProgress;

                constrainPosition(char);
                updatePosition(char);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            };

            animate();
        }

        // ========== „Éõ„ÉÉ„ÉóÁßªÂãï ==========
        function hopMove(char) {
            const bounds = getMovementBounds(char.moveArea);
            let hopsRemaining = Math.floor(Math.random() * 5) + 3;
            
            const hop = () => {
                if (!char.isMoving || hopsRemaining <= 0) return;

                const hopDistance = 30 + Math.random() * 50;
                const angle = Math.random() * Math.PI * 2;
                const targetX = char.x + Math.cos(angle) * hopDistance;
                const targetY = char.y + Math.sin(angle) * hopDistance;

                // Âêë„ÅçË®≠ÂÆö
                if (targetX > char.x && char.direction === -1) {
                    char.img.style.transform = 'scaleX(1)';
                    char.direction = 1;
                } else if (targetX < char.x && char.direction === 1) {
                    char.img.style.transform = 'scaleX(-1)';
                    char.direction = -1;
                }

                const duration = 400 + Math.random() * 200;
                const startX = char.x;
                const startY = char.y;
                const startTime = Date.now();

                const animateHop = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    char.x = startX + (targetX - startX) * progress;
                    char.y = startY + (targetY - startY) * progress;

                    // „Ç∏„É£„É≥„Éó„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                    const jumpHeight = Math.sin(progress * Math.PI) * 20;
                    constrainPosition(char);
                    char.element.style.left = `${char.x}px`;
                    char.element.style.top = `${char.y - jumpHeight}px`;

                    if (progress < 1) {
                        requestAnimationFrame(animateHop);
                    } else {
                        hopsRemaining--;
                        if (char.isMoving && hopsRemaining > 0) {
                            setTimeout(hop, 200 + Math.random() * 300);
                        }
                    }
                };

                animateHop();
            };

            hop();
        }

        // ========== „Ç§„Éº„Ç∏„É≥„Ç∞Èñ¢Êï∞ ==========
        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        // ========== ‰ΩçÁΩÆÂà∂Á¥Ñ ==========
        function constrainPosition(char) {
            const bounds = getMovementBounds(char.moveArea);
            
            if (char.x < bounds.minX) char.x = bounds.minX;
            if (char.x > bounds.maxX - char.actualSize) char.x = bounds.maxX - char.actualSize;
            if (char.y < bounds.minY) char.y = bounds.minY;
            if (char.y > bounds.maxY - char.actualSize) char.y = bounds.maxY - char.actualSize;
        }

        // ========== ‰ΩçÁΩÆÊõ¥Êñ∞ ==========
        function updatePosition(char) {
            char.element.style.left = `${char.x}px`;
            char.element.style.top = `${char.y}px`;
        }

        // ========== „ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ ==========
        function handleClick(e, char) {
            e.stopPropagation();
            
            // ÁµµÊñáÂ≠ó„Ç®„Éï„Çß„ÇØ„Éà
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    createEmojiParticle(char, i);
                }, i * 200);
            }

            // ÊÑõÁùÄÂ∫¶3„ÅÆÂ†¥Âêà„ÄÅ‰∏ÄÊôÇÁöÑ„Å´Êáê„Åè
            if (char.affection === 3 && !char.isFriendly) {
                if (Math.random() < 0.3) { // 30%„ÅÆÁ¢∫Áéá
                    char.isFriendly = true;
                    char.friendlyUntil = Date.now() + (10000 + Math.random() * 20000);
                    startGentleHearts(char);
                }
            }
        }

        // ========== „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ ==========
        function handleDoubleClick(e, char) {
            e.stopPropagation();
            showOverlay(char);
        }

        // ========== ÁµµÊñáÂ≠ó„Éë„Éº„ÉÜ„Ç£„ÇØ„É´ ==========
        function createEmojiParticle(char, index) {
            const particle = document.createElement('div');
            particle.className = 'emoji-particle';
            particle.textContent = char.emoji[index % char.emoji.length];
            
            const driftX = (Math.random() - 0.5) * 60;
            particle.style.setProperty('--drift-x', `${driftX}px`);
            particle.style.left = `${char.x + char.actualSize / 2}px`;
            particle.style.top = `${char.y + char.actualSize / 3}px`;
            
            document.getElementById('grassland-container').appendChild(particle);
            
            setTimeout(() => particle.remove(), 2000);
        }

        // ========== Êéß„Åà„ÇÅ„Å™„Éè„Éº„Éà ==========
        function startGentleHearts(char) {
            const interval = setInterval(() => {
                if (!char.isFriendly || Date.now() > char.friendlyUntil) {
                    clearInterval(interval);
                    char.isFriendly = false;
                    return;
                }

                if (Math.random() < 0.3) {
                    const heart = document.createElement('div');
                    heart.className = 'heart-particle';
                    heart.textContent = '‚ô°';
                    heart.style.left = `${char.x + char.actualSize / 2}px`;
                    heart.style.top = `${char.y + char.actualSize / 4}px`;
                    
                    document.getElementById('grassland-container').appendChild(heart);
                    setTimeout(() => heart.remove(), 3000);
                }
            }, 2000);
        }

        // ========== „Ç™„Éº„Éê„Éº„É¨„Ç§Ë°®Á§∫ ==========
        function showOverlay(char) {
            const overlay = document.getElementById('overlay');
            const overlayImage = document.getElementById('overlay-image');
            overlayImage.src = char.detailImage;
            overlay.classList.add('active');
        }

        // ========== „Ç™„Éº„Éê„Éº„É¨„Ç§Èñâ„Åò„Çã ==========
        function closeOverlay() {
            document.getElementById('overlay').classList.remove('active');
        }

        // ========== GIF„Çµ„Ç§„ÇØ„É´ ==========
        function startGifCycle(char) {
            setInterval(() => {
                if (Math.random() < 0.2 && char.gifImage) { // 20%„ÅÆÁ¢∫Áéá
                    const originalSrc = char.img.src;
                    char.img.src = char.gifImage;
                    
                    setTimeout(() => {
                        char.img.src = originalSrc;
                    }, char.gifDuration);
                }
            }, 10000 + Math.random() * 10000);
        }

        // ========== ÊÑõÁùÄÂ∫¶: Ëøë„Å•„Åè ==========
        function startAffectionBehavior(char) {
            setInterval(() => {
                if (!char.isMoving && char.moveType > 1) return;
                if (char.affection === 3 && !char.isFriendly) return;
                
                if (Math.random() < 0.3) {
                    const dx = mouseX - char.x - char.actualSize / 2;
                    const dy = mouseY - char.y - char.actualSize / 2;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 100 && distance < 500) {
                        const moveDistance = 50 + Math.random() * 50;
                        const targetX = char.x + (dx / distance) * moveDistance;
                        const targetY = char.y + (dy / distance) * moveDistance;
                        
                        moveTowardsTarget(char, targetX, targetY);
                    }
                }
            }, 2000);
        }

        // ========== ÊÑõÁùÄÂ∫¶: ÈÄÉ„Åí„Çã ==========
        function startAvoidanceBehavior(char) {
            setInterval(() => {
                if (!char.isMoving && char.moveType > 1) return;
                
                const dx = mouseX - char.x - char.actualSize / 2;
                const dy = mouseY - char.y - char.actualSize / 2;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 150 && Math.random() < 0.5) {
                    const moveDistance = 80 + Math.random() * 70;
                    const targetX = char.x - (dx / distance) * moveDistance;
                    const targetY = char.y - (dy / distance) * moveDistance;
                    
                    moveTowardsTarget(char, targetX, targetY);
                }
            }, 1500);
        }

        // ========== „Çø„Éº„Ç≤„ÉÉ„Éà„Å∏ÁßªÂãï ==========
        function moveTowardsTarget(char, targetX, targetY) {
            const bounds = getMovementBounds(char.moveArea);
            targetX = Math.max(bounds.minX, Math.min(targetX, bounds.maxX - char.actualSize));
            targetY = Math.max(bounds.minY, Math.min(targetY, bounds.maxY - char.actualSize));

            // Âêë„ÅçË®≠ÂÆö
            if (targetX > char.x && char.direction === -1) {
                char.img.style.transform = 'scaleX(1)';
                char.direction = 1;
            } else if (targetX < char.x && char.direction === 1) {
                char.img.style.transform = 'scaleX(-1)';
                char.direction = -1;
            }

            const duration = 800 + Math.random() * 400;
            const startX = char.x;
            const startY = char.y;
            const startTime = Date.now();

            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = easeInOutQuad(progress);

                char.x = startX + (targetX - startX) * easeProgress;
                char.y = startY + (targetY - startY) * easeProgress;

                constrainPosition(char);
                updatePosition(char);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            };

            animate();
        }

        // ========== Ëµ∑Âãï ==========
        init();
    </script>
</body>
</html>
